[1,["e5coUac6xGC4wZ55wo7OnB","ffTBZxIfNCl62rIQOVNFz2@6c48a","97H+T+abRJHpjz8M4naiLW","360Cj1jaROVbRxavrFIBqo","4cQYhlp9RKlpLvlHmKmYOl","c0e9AuDytNF4ZDi384YG2N@06ee4","feumUiNndHyZ+FFvlAwsg9@c2f9c","35CddkUUtPAJqw8PQjD+bP","a1kJ1g2lpDmZjrgQzMOa4G","462hsBbJRBAYlZmysRJMK9","aekLJgAt9MQqvU41X7G/ee","90Q6glXPFEFJ4v4cNATiL1@6c48a","feumUiNndHyZ+FFvlAwsg9@99785","acnQgIgMNBlLYwtPs5drLV","e3rnxh6k5FRKOgxWkDWhQL","feLGmKcZFBlb40hyVi0KQb","adsCEkkSVP5J2t5nEkpKgi","f2XNrsuvlBAL/o+swN2BMN","65JzG5kPtGFbR8MbX4Fa75","b1V7n64I5Bfbc7y4Q505u1","2fF+fj45FAW5NkSUMUzMTr","9cZjG57zZBcIrl1dmImS3h","d7+JZ3zoxLVL3OalrBx2S6","cb4wO/+EhEuaIIbqEJw4C2","35fPogKSxNcKAfPKGt42lz","22VBrz+flB+LDmiP/dbJYP","98dyWdVdtBYoZ3sAVrMGQ3","49FuKbqAJOYJmHTyJH6U1B","82pbEQzwxIqpUoLeBY51NZ","bbmM3iDFJEmKmrBCGe5FeU","91W08v+nRGJopwxWZ8FtMD","03Q6VzmqNEUIYyIz95qjCE","3807lb+lNP0YmoLUlwDP+l","cf/WHGurVNE4h8l76xJ8rt","b4aDiQX3ZDSqNveSjpKFuR","70wkrFxmtDvoSwRrO3phzf","c83zaqG6pF1YD5YKbow5fi","44YbVTdIFIfbK04lSoED85","8eokiQZixB56/SMXOuz0yJ","8dok32iB9PLYNhfy8l9eaL","334vQn99FMh5e4z/r9gcZx","2aOa75zN1F2ZNHgmNqJit/","acxJXcWgdOe45eLRZCVvxq","5eyhnfXPlJXJEforMETpaY","77EOpFXk9IHYN6IZsIkIpw","ffqvPKKaVJxaOErjkiIVSU","971qvicqJG96hAWC+jhYe/","dbzgDu5ntLc7cE7H7sk3sP","5egoReHwRLRZo3EuOznZvK","62xCzk7xxBALisS/Qmyk2Z","b4vFAv44VL6YwhOkJVvhbp","c4JInuM0dCPqbPPgabK6e4","aeGCet+gRAsqLdXw55xkan","2cAeEeUqZClYqWdmRXF2wc","12Y9dMgWdJKJGmTiZyQR9H@fc873","73WnueNaxAcLtrGN2+6MQu","74xKGXh6RL1Kwxf6WheXkT","cbF5Sq5kpCt7K2XNJn2zeY","2fGS6p8TBIUbsytWz1uRjZ","7fEuqsjBVPTJUeOAJZBn9A","01M2mAlNhJbqRRu4G4iUIJ@6c48a","a3zQCfCrBCDZJ4uf2rk5u8"],["target","node","prefab","source","targetInfo","_parent","asset","root","_mesh","_particleSystem","_mainTexture","value","_slimeSettingsPrefab","_key","data","collider","configPrefab","_joystick","_renderer","_animHelper","_damageBlink","_collider","_divideDashTarget","bulletPrefab","_onAbsorbedAudio","_configPrefab","_outOfSafeAreaSfx","_absorbFoodAudio","_absorbSlimeAudio","mainTexture","_effectAsset"],[["cc.Node",["_name","_layer","_active","_objFlags","__editorExtras__","_prefab","_components","_parent","_children","_lrot","_lscale","_euler","_lpos"],-2,4,9,1,2,5,5,5,5],["cc.RealKeyframeValue",["interpolationMode","value","rightTangentWeight","leftTangentWeight","rightTangent","leftTangent"],-3],["cc.Node",["_name","_layer","_components","_prefab","_children","_lpos","_parent","_lrot","_euler","_lscale"],1,12,4,2,5,1,5,5,5],["cc.CurveRange",["mode","multiplier","constantMin","constantMax","constant","spline","splineMin","splineMax"],-2,4,4,4],["cc.TargetOverrideInfo",["propertyPath","targetInfo","target","source","sourceInfo"],2,4,1,1,4],["cc.GradientRange",["_mode","colorMin","colorMax","gradient","color"],2,5,5,4,5],["cc.ShapeModule",["radius","length","_angle","_enable","emitFrom","randomDirectionAmount","arcMode","sphericalDirectionAmount","randomPositionAmount","arcSpeed","_rotation"],-6,4,5],["cc.Node",["_name","_layer","_components","_prefab","_parent","_children"],1,2,4,1,2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents","mountedChildren","removedComponents"],2,1,9,9,9,9],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["cc.CapsuleCollider",["_radius","_isTrigger","_cylinderHeight","node","__prefab","_center"],0,1,4,5],["cc.ParticleSystemRenderer",["_renderMode","_mainTexture","_mesh"],2,6,6],["cc.PrefabInfo",["fileId","root","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,1,9,2],["cc.PrefabInfo",["fileId","root","asset","instance"],2,1,6,4],["0c5d3ln13dJiYvGTuhGpTgh",["__prefab","node"],3,4,1],["cc.RigidBody",["_group","_type","node","__prefab","_linearFactor","_angularFactor"],1,1,4,5,5],["cc.ParticleSystem",["scaleSpace","duration","playOnAwake","_simulationSpace","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],-2,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.Burst",["_time","count"],2,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.VelocityOvertimeModule",["_enable","x","y","z","speedModifier"],2,4,4,4,4],["cc.LimitVelocityOvertimeModule",["_enable","dampen","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.MeshRenderer",["_name","node","__prefab","_materials","lightmapSettings","_mesh"],2,1,4,3,4,6],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Prefab",["_name"],2],["32af9xWdKpDW41S3+S2FSfL",["_decayPercentagePerSecond","_fixedDecayValue","node","__prefab"],1,1,4],["cc.CompPrefabInfo",["fileId"],2],["12ea43w32ZDAL2+IVCNZlsZ",["duration","easing","useRelativeValue","node","__prefab","target"],0,1,4,1],["c83f3h67FpJDoLcaBUEDjiF",["node","__prefab"],3,1,4],["cc.TargetInfo",["localID"],2],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["5b19dq0eWhJUbFOk5xsaEiO",["node","__prefab","_renderNode","_outOfSafeAreaParticles","onSizeChanged","_onVanished"],3,1,4,1,2,9,9],["e12febRNOJObKlsUQ4Ygfbr",["node","__prefab","onChangedSteering","_joystick"],3,1,4,9,1],["1a3618UqwJAoY8Y8z5qOgFR",["node","__prefab","_setModelColors"],3,1,4,9],["e11ad+wW8dJeaOLW/7k4mqn",["_skillKey","__prefab","slime","_onSpeedBoostActivated","_onSpeedBoostDeactivated","_skillEventData"],2,4,1,9,9,4],["SkillEventData",["_listenEvents","_pressedEvent","_releasedEvent"],0],["c223bQVaKZH2bqnzZQ0cKnq",["_a2","_b2","node","__prefab","onMaxSpeedChanged","_slimeSettingsPrefab"],1,1,4,9,6],["21c126rGLFO86lqv3S7mROs",["node","__prefab","slime","collider","_onAbsorbedAudio"],3,1,4,1,1,6],["3bad91bJJROtrq/iYNkKQPI",["node","__prefab","_renderer"],3,1,4,1],["ac879rTendCEbpZWFz/jexs",["node","__prefab","_key"],3,1,4,6],["4558d+lqS9LYKXyNOvP2g9u",["__prefab","_shadows"],3,4,12],["405d5QJlkND5qnJHSPRCLqD",["node","__prefab","slime","collider"],3,1,4,1,1],["cc.Gradient",["alphaKeys"],3,9],["cc.AlphaKey",["alpha","time"],1],["cc.SizeOvertimeModule",["_enable","separateAxes","size","x","y","z"],1,4,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.RotationOvertimeModule",["x","y","z"],3,4,4,4],["cc.TextureAnimationModule",["frameOverTime","startFrame"],3,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["05d15J3lUpD5JAIXsL9fkKr",["_frequency","__prefab","_tintCurve","_renderNode"],2,4,4,1],["c1182oPML1BJKpLNmjmdZdK",["node","__prefab","_modelHolder","_entries","_onModelSet"],3,1,4,1,9,9],["ModelEntry",["id","prefab"],2,6],["55773MFO2ZKyY0wJczKXkl/",["_key","node","__prefab","_setModelColors"],2,1,4,9],["cc.ModelLightmapSettings",[],3],["64be3B0iyJOGr/7vUdvlzSM",["node","__prefab","_slime","_deathParticles","_onBeginDisable"],3,1,4,1,2,9],["8c640ND3JRCiLZxYhwMh9hf",["_a","_b","node","__prefab","onScaleChanged","target","_slimeSettingsPrefab"],1,1,4,9,1,6],["39057j6vj9KwIARqrrUYku8",["node","__prefab","_animHelper"],3,1,4,1],["45036yzSCxAR7bKOf+btmz5",["node","__prefab","_slime","_onDivide","_onUnite","_uniteVFX"],3,1,4,1,9,9,1],["37b85WpHzdBn41+pXJNQa6l",["node","__prefab"],3,1,4],["53d6ak+3nROapxBv5lms9wF",["node","__prefab"],3,1,4],["998c54116RP+60xSJ3vqUX7",["speed","maxSpeed","node","__prefab","body","_collisionArea","_slime"],1,1,4,1,1,1],["2e8808Ox4tBXYEZQBYFchhl",["node","__prefab","renderNode","_velocityComponent"],3,1,4,1,1],["161b4kJT95DkrpxYg3sCEYb",["_enabled","node","__prefab","slime","slimeBody","slimeDirection","_onShoot","configPrefab","bulletPrefab"],2,1,4,1,1,1,9,6,6],["7aa59VYt9NOyp9K157gXXfU",["_eventID","node","__prefab","_onEventRaised"],2,1,4,9],["f6ce3V3GtZET7YfWjO8OsBV",["slimeEvent","node","__prefab","_onEventRaised"],2,1,4,9],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_states","_defines","_props"],1,12]],[[3,1],[25,0,2],[28,0,2],[12,0,1,2,2],[9,0,1,3,3],[57,0,1,2],[50,0,1,2],[1,0,1,4,5,5],[4,0,3,2,1,2],[3,4,2],[0,0,1,7,6,5,3],[9,0,1,3],[0,0,1,7,8,5,3],[58,0,1,2,3,2],[1,0,4,2,5,3,6],[3,0,5,2],[7,0,1,4,2,3,3],[33,0,1,2,2],[3,0,2,3,4],[5,1],[48,0,1,3],[4,0,2,1,2],[4,0,3,4,2,1,2],[1,0,1,3],[27,0,1,1],[29,0,1,1],[1,0,1,2,3,5],[1,0,2],[30,0,1,2,3],[0,3,4,5,3],[2,0,1,6,2,3,3],[13,0,1,3,2,2],[14,0,1],[5,0,3,2],[3,0,1,6,7,3],[17,1,1],[47,0,1],[49,0,1,2,3,4,5,3],[1,0,2,3,4],[1,0,4,5,4],[51,0,1,2,1],[52,0,1,2,1],[53,0,1,1],[54,0,1,2,3,4,1],[13,0,1,2,2],[14,1,0,1],[31,0,1,2,2],[32,0,1,2,3],[34,0,1,2,2],[9,0,1,2,3,4],[15,0,1,2,3,3],[44,0,1,2,1],[5,4,1],[3,0,1,5,3],[18,1,1],[20,2,3,4,5,1],[59,1],[23,0,2],[0,0,1,6,5,3],[0,0,1,8,5,3],[0,0,2,7,6,5,9,10,11,3],[8,0,1,3,2,2],[10,1,0,2,3,4,5,4],[16,0,1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,5],[16,0,1,4,2,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,5],[17,0,1,2],[1,0,1,4,2,5,3,7],[19,0,1,2,3,4,2],[19,1,2,3,4,1],[11,2,1,1],[21,1,2,3,4,5,1],[22,0,1,2,3],[0,0,1,8,6,5,3],[0,0,1,7,8,6,5,3],[0,0,2,1,7,6,5,4],[0,0,1,7,5,12,3],[2,0,1,4,2,3,3],[2,0,1,4,2,3,5,7,8,3],[2,0,1,2,3,3],[2,0,1,6,2,3,5,3],[2,0,1,4,2,3,5,3],[2,0,6,2,3,7,9,8,2],[7,0,1,2,3,3],[7,0,1,4,5,2,3,3],[24,0,1,2,3,3],[12,0,1,2,3,4,2],[26,0,1,2,3,4,5,4],[4,0,3,1,2],[8,0,1,2,2],[8,0,1,4,3,2,5,2],[35,0,1,1],[36,0,1,2,3,4,5,1],[37,0,1,2,3,1],[38,0,1,2,1],[39,0,1,2,3,4,5,2],[40,0,1,2,4],[41,0,1,2,3,4,5,3],[15,0,2,3,4,5,2],[42,0,1,2,3,4,1],[43,0,1,2,1],[45,0,1,1],[46,0,1,2,3,1],[10,0,3,4,5,2],[10,1,0,3,4,5,3],[5,0,1,2,2],[18,0,1,2],[6,3,4,5,0,1,2,9,10,7],[6,4,0,6,1,2,9,6],[6,3,4,0,1,2,9,10,6],[6,3,5,7,8,0,1,2,9,10,8],[20,0,1,2,3,4,5,3],[11,0,1,2],[11,1,1],[55,0,1,2,3,2],[56,0,1,2,3,4,1],[21,0,1,2,3,4,2],[60,0,1,2,3,4,1],[61,0,1,2,3,4,5,6,3],[62,0,1,2,1],[63,0,1,2,3,4,5,1],[64,0,1,1],[65,0,1,1],[66,0,1,2,3,4,5,6,3],[67,0,1,2,3,1],[68,0,1,2,3,4,5,6,7,8,2],[69,0,1,2,3,2],[70,0,1,2,3,2],[71,0,1,2,4],[72,0,1,2,3]],[[[[71,".bin",3383603168,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":224,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":224,"count":4,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,0],"maxPosition",8,[1,0.5,0.5,0]]],-1],0,0,[],[],[]],[[[57,"P-Slime-SkillConfig-SpeedBoost"],[58,"P-Slime-SkillConfig-SpeedBoost",1,[[84,0.07,2,-2,[1,"15xDPLe6hFN7fdd5H6eb1Q"]]],[3,"b4mH3uezlFaZDdfdDSs2Yr",-1,0]]],0,[0,7,1,0,1,1,0,14,1,2],[],[],[]],[[[57,"P_Slime_Player"],[76,"P_Slime_Player",1,[-70,-71,-72],[[-64,-65,-66,[86,0.3,37,true,-68,[1,"2c1OIUOiBHIr1ew/NQ7jZq"],-67],[24,-69,[1,"f7+QQKA6RD1L2WExsBiFSV"]]],1,1,1,4,4],[85,"2dDH59HKVEUbpzxX0xslHL",-63,0,[[21,["_onSpeedBoostActivated","2","target"],-5,[2,["7fwggUvH5LC59FXUEjf0Tk"]]],[21,["_onSpeedBoostActivated","3","target"],-6,[2,["cadr/nBK5NsoMoexyHRZSd"]]],[21,["_onSpeedBoostDeactivated","2","target"],-7,[2,["7fwggUvH5LC59FXUEjf0Tk"]]],[21,["_onSpeedBoostDeactivated","3","target"],-8,[2,["cadr/nBK5NsoMoexyHRZSd"]]],[22,["_trailModule","_particleSystem"],-10,[2,["a5P6TIs+5Ls4OPTv0QoFGM"]],-9,[2,["a5P6TIs+5Ls4OPTv0QoFGM"]]],[21,["_onDivide","1","target"],-11,[2,["770U1DnYtANLdgJ9pC/w7j"]]],[21,["_onDivide","2","target"],-12,[2,["6cmhl3luhIva4qezHgFbbb"]]],[21,["_onDivide","3","target"],-13,[2,["a6jFWYxDxHVqo4HL6I0+j4"]]],[8,["_onSpeedBoostActivated","2","target"],-15,-14,[2,["7fwggUvH5LC59FXUEjf0Tk"]]],[8,["_onSpeedBoostActivated","3","target"],-17,-16,[2,["cadr/nBK5NsoMoexyHRZSd"]]],[8,["_onSpeedBoostDeactivated","2","target"],-19,-18,[2,["7fwggUvH5LC59FXUEjf0Tk"]]],[8,["_onSpeedBoostDeactivated","3","target"],-21,-20,[2,["cadr/nBK5NsoMoexyHRZSd"]]],[22,["_trailModule","_particleSystem"],-23,[2,["46sFcXkiZMsbbe/5yoZ3ev"]],-22,[2,["46sFcXkiZMsbbe/5yoZ3ev"]]],[8,["_onSpeedBoostActivated","4","target"],-25,-24,[2,["6bxaJCLf1AE4H8f+6G6Ybt"]]],[8,["_onSpeedBoostDeactivated","4","target"],-27,-26,[2,["6bxaJCLf1AE4H8f+6G6Ybt"]]],[8,["_setModelColors","0","target"],-29,-28,[2,["6cmhl3luhIva4qezHgFbbb"]]],[8,["_setModelColors","0","target"],-31,-30,[2,["a6jFWYxDxHVqo4HL6I0+j4"]]],[8,["_setModelColors","0","target"],-33,-32,[2,["6bxaJCLf1AE4H8f+6G6Ybt"]]],[87,["_renderer","3"],-34,[2,["c9WNp9yR9S7YW9T85B0vOT"]]],[8,["_setModelColors","0","target"],-36,-35,[2,["7fwggUvH5LC59FXUEjf0Tk"]]],[8,["_setModelColors","0","target"],-38,-37,[2,["7fwggUvH5LC59FXUEjf0Tk"]]],[8,["_onDivide","1","target"],-40,-39,[2,["6cmhl3luhIva4qezHgFbbb"]]],[8,["_onDivide","2","target"],-42,-41,[2,["a6jFWYxDxHVqo4HL6I0+j4"]]],[8,["_setModelColors","0","target"],-44,-43,[2,["66The7AxxOiZz2mY5OUMQa"]]],[8,["_setModelColors","0","target"],-46,-45,[2,["4eDQtL1MJLiZKnijxhFL9w"]]],[22,["_trailModule","_particleSystem"],-48,[2,["9f6UUmmlVNSZdqgv5NJuKz"]],-47,[2,["9f6UUmmlVNSZdqgv5NJuKz"]]],[22,["_trailModule","_particleSystem"],-50,[2,["85OLlHvJBEXIdjejxPU2Jz"]],-49,[2,["85OLlHvJBEXIdjejxPU2Jz"]]],[22,["_trailModule","_particleSystem"],-52,[2,["27CZcpywtB6qv96snkU3RB"]],-51,[2,["27CZcpywtB6qv96snkU3RB"]]],[22,["_trailModule","_particleSystem"],-54,[2,["a5P6TIs+5Ls4OPTv0QoFGM"]],-53,[2,["a5P6TIs+5Ls4OPTv0QoFGM"]]],[8,["_shadows","0"],-56,-55,[2,["1a/3y3FuFW/4deXCZfP1J8"]]],[8,["_shadows","1"],-58,-57,[2,["beBR4u63hG0r3AcRga+N66"]]],[8,["_shadows","2"],-60,-59,[2,["7df/0VvUpJ/7g7ySaz4ALT"]]],[22,["_renderer"],-62,[2,["43i5kMzyxDr5m2A4n7Gr7Y"]],-61,[2,["04DXdN2HdOUbqQ3OSn/guW"]]]],[-1,-2,-3,-4]]],[29,0,null,[31,"52IagJDelNTaXzNDmOb9sR",-74,[61,"52m402fLZI6KpR714e/NKo",1,[[25,[2,["52IagJDelNTaXzNDmOb9sR"]],[[45,-73,[1,"b3pI3K7DFCz4Rfo0JwBHzT"]]]],[25,[2,["6cmhl3luhIva4qezHgFbbb"]],[[32,[1,"0e4IKPwDdIh55U+mbljObz"]]]],[25,[2,["a6jFWYxDxHVqo4HL6I0+j4"]],[[32,[1,"566zspn1pA/LEtjIrrWdng"]]]]],[[28,"VFX-Divide",["_name"],[2,["52IagJDelNTaXzNDmOb9sR"]]],[46,["_lpos"],[2,["52IagJDelNTaXzNDmOb9sR"]],[1,0,0.286,0]],[46,["_lrot"],[2,["52IagJDelNTaXzNDmOb9sR"]],[3,0,0,0,1]],[46,["_euler"],[2,["52IagJDelNTaXzNDmOb9sR"]],[1,0,0,0]],[28,false,["_active"],[2,["770U1DnYtANLdgJ9pC/w7j"]]]]],0]],[29,0,null,[31,"8bhJkX2KhDFZy3y4KeLdh8",-79,[61,"8cXpJJ2EhEzbvV0Z4Ive1I",1,[[25,[2,["7fwggUvH5LC59FXUEjf0Tk"]],[[32,[1,"cfA10YBVRHSJ4Ac/A9HHsr"]]]],[25,[2,["6bxaJCLf1AE4H8f+6G6Ybt"]],[[32,[1,"279dYdA3ZJo5v/bR1yoMoj"]]]]],[[47,"VFX-Dash",["_name"],-75],[17,["_lpos"],-76,[1,0,0,0]],[17,["_lrot"],-77,[3,0,0,0,1]],[17,["_euler"],-78,[1,0,0,0]]]],2]],[29,0,null,[31,"e42z2/c/9EsZKvQ0ZBo285",-84,[88,"3a864fOsVECL7D0gPhZgKF",1,[[47,"VFX-Unite",["_name"],-80],[17,["_lpos"],-81,[1,0,0.5,0]],[17,["_lrot"],-82,[3,0,0,0,1]],[17,["_euler"],-83,[1,0,0,0]]]],1]],[29,0,null,[31,"a3GP0VlYhaeq91OPUXRyaX",-94,[89,"795c++AAlHmLNTR490tt3h",1,[[90,[2,["a3GP0VlYhaeq91OPUXRyaX"]],[-91,-92,-93]]],[[25,[2,["a3GP0VlYhaeq91OPUXRyaX"]],[[24,-90,[1,"58CJQS9D5AuKaMcbbrIYYB"]]]]],[[47,"S_Shadow_01",["_name"],-85],[17,["_lpos"],-86,[1,0,0,0]],[17,["_lrot"],-87,[3,0,0,0,1]],[17,["_euler"],-88,[1,0,0,0]],[17,["_lscale"],-89,[1,1,1,1]],[48,["_materials","0"],[2,["d95gYeJJRT0odlGQ2lDhMJ"]],20],[28,false,["_active"],[2,["45R3qSajFbCaSe+dewfFEw"]]],[28,false,["_active"],[2,["79Gf0YgihSqrq9/HnjSm/j"]]],[48,["_materials","0"],[2,["38RB14XUtVfbXMI//Uc+5O"]],21],[28,false,["_active"],[2,["1a/3y3FuFW/4deXCZfP1J8"]]],[48,["_materials","0"],[2,["6c+Bz34bhUkaZlSuorJY9X"]],22]],[[2,["b5J15/sBFOzYEs9MVBGKBB"]]]],13]],[12,"Render",1,1,[-95,-96,-97,-98,5,-99],[3,"5aeJQ07X1DqLtkZNYXWrFE",1,0]],[12,"Scripts",1,1,[-100,-101,-102,-103,-104,-105,-106,-107,-108],[3,"cdsvdWmQtNUrkTcCMUnBAI",1,0]],[91,1,[1,"0f8gOs5jNFT5RgvfZftfBy"],6,[-114,-115],[[4,"c223bQVaKZH2bqnzZQ0cKnq","setSlimeSize",-111],[4,"8c640ND3JRCiLZxYhwMh9hf","setSlimeSize",-112],[4,"39057j6vj9KwIARqrrUYku8","setSlimeSize",-113]],[[4,"cc.ParticleSystem","play",-109],[4,"cc.ParticleSystem","play",-110]]],[77,"VFX-Vanished",1,[-119],[[-116,[24,-117,[1,"ebjN0a3t9EDbP5cuzWr6DD"]],[45,-118,[1,"65AGbY09RDVJjcQwiPSE7H"]]],1,4,4],[3,"6bsssQo6BKYp+sVuABoW+a",1,0],[1,0,0.5,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[78,"Movement",1,[[-120,[92,-123,[1,"512T7dvGlNyoHgFysQ6urK"],[[4,"998c54116RP+60xSJ3vqUX7","setDirection",-122]],-121]],1,4],[3,"eeaTno4gBFdJxEZy6EntVB",1,0]],[72,"Set Model Colors",1,[-139,-140,-141,-142,-143],[[93,-138,[1,"b3qArfdyhPzYjy/CZ32kHL"],[[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-124],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-125],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-126],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-127],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-128],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-129],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-130],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-131],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-132],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-133],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-134],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-135],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-136],[4,"55773MFO2ZKyY0wJczKXkl/","setModelColor",-137]]]],[3,"29QlPkHNNKTYXJAStxrhWx",1,0]],[79,"VFX-Burst",1,9,[[-144,[24,-145,[1,"91sFE51rhA0rcB86d89OCI"]],[45,-146,[1,"2awaWQRJJDmrSB9EnezBEE"]]],1,4,4],[3,"74U38a4GJFAJxyvuxOsmBG",1,0],[1,0,0,-0.5]],[94,83,[1,"fdBuTBrJdC4ohAM52VQJl6"],8,[[4,"5b19dq0eWhJUbFOk5xsaEiO","addDecayMultiplier",1],[4,"c223bQVaKZH2bqnzZQ0cKnq","addMaxSpeedMultiplier",-149],[11,"cc.ParticleSystem","play"],[11,"cc.ParticleSystem","play"],[11,"cc.ParticleSystem","play"],[4,"ac879rTendCEbpZWFz/jexs","playSFX",-150],[49,"37b85WpHzdBn41+pXJNQa6l","setBool","dash,true",-151]],[[4,"5b19dq0eWhJUbFOk5xsaEiO","removeDecayMultiplier",1],[4,"c223bQVaKZH2bqnzZQ0cKnq","removeMaxSpeedMultiplier",-147],[11,"cc.ParticleSystem","stop"],[11,"cc.ParticleSystem","stop"],[11,"cc.ParticleSystem","stop"],[49,"37b85WpHzdBn41+pXJNQa6l","setBool","dash,false",-148]],[95,true,1,2]],[82,"TS-Animation-Helper",1,[-152],[3,"bb1ufzVexAorLHTJUifATG",1,0]],[80,"VFX-Burn",1,[-155],[[-153,[24,-154,[1,"38AXUVE4VCX4dNTEBf9kY4"]]],1,4],[3,"3eUYDk0nlARpdVWbXyoWsi",1,0],[1,0,0.635,0]],[12,"VFX-Divide",1,11,[-156,-157,-158,-159],[3,"19rqCZrwhL/bBFmX+WbFse",1,0]],[12,"VFX-Unite",1,11,[-160,-161,-162,-163],[3,"b1BYUQE3hEVbe7M7kr4FxJ",1,0]],[2,["a3GP0VlYhaeq91OPUXRyaX"]],[58,"Max Speed",1,[[96,-0.01,2.8,-164,[1,"70p5KBIz5OBpe8hAkAppt3"],[[4,"998c54116RP+60xSJ3vqUX7","setMaxSpeed",10]],57]],[3,"36Io80+phOxqx12KUej+iG",1,0]],[30,"Absorb Players inner trigger",2,6,[[-165,[50,4,4,-166,[1,"0c0jbsSARE9Jj5ddrm3+nK"]],[98,-168,[1,"f1popNdbtIsZOeXcUO1ssd"],8,-167,64]],1,4,4],[3,"8bRHgnMnRMToCulO0yF9zr",1,0]],[59,"Skills",1,[2,4,3],[3,"5f+AYJVq9KZo+xDeEMma+v",1,0]],[2,["e42z2/c/9EsZKvQ0ZBo285"]],[2,["8bhJkX2KhDFZy3y4KeLdh8"]],[12,"Slime",1,7,[-169,-170,-171],[3,"a5RpJq7XpNoo+jYhLoY+BK",1,0]],[12,"VFX-Dash",1,11,[-172,-173,-174],[3,"fc8/Hr+Z1LVL2nWqpeaPfi",1,0]],[81,"Quad_PlayerCircle",5,[[-175,[99,-177,[1,"43i5kMzyxDr5m2A4n7Gr7Y"],-176]],1,4],[44,"a4LXRAastByKAX/ZztHXz9",1,24],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,2.6,3,1],[1,-90,0,0]],[12,"Stats",1,24,[19,-178,-179],[3,"b56jBv4e5F/aF0MAJx9o59",1,0]],[12,"Skills",1,7,[-180,-181,-182],[3,"46aISSPV1MDYjDUTO+KIBb",1,0]],[83,"Divide",1,28,[-184,-185],[-183],[3,"e9ljFwTa1AoLfLpZszv7q8",1,0]],[30,"Speed Boost",1,28,[[13,[51,-186,[1,"99dMqNgEhC4YrazUQEALwn"],63]],1,4],[3,"b6oXlkgYdIoLjUKcMm+AHD",1,0]],[100,[1,"adBeGJ/ZBJLIb2OyBn+7th"],[[null,-187,-188],0,1,1]],[30,"Absorb Food",8,6,[[[50,16,4,-189,[1,"50kgxTgQNHN4n9vd3GEh/B"]],-190,[101,-192,[1,"43L7xa1qJKLZF6VPvrBu9C"],8,-191]],4,1,4],[3,"b4j/p9puFJXpLleB/zPglv",1,0]],[102,0.8,1,[1,"89aSyEDb1GYLximAlcyJm4"],[1,0,0.9,0]],[63,0,1,false,0,15,[1,"d2A33fUHpPdq88JJs5kQM8"],[[10,null],6,0],[104,2,[4,4281281194],[4,4281805024]],[18,3,0.2,0.4],[0],[0],[18,3,4,8],[0],[0],[0],[0],[18,3,0.4,0.8],[9,1.5],[9,10],[0],[[35,[18,3,2,6]]],[54,[33,1,[36,[[20,255,0.5602678571428571],[20,0,0.7008928571428572]]]]],[106,true,2,1,0.6,1,0.5235987755982988,[0],[1,90,0,0]],[37,true,true,[15,1,[6,[0,1],[[26,2,1,1,1],[38,2,1,1]]]],[34,2,1.5,[6,[0,0.32564102564102565,0.6282051282051282,1],[[14,2,8.233333333333334,1,8.233333333333334,1],[7,2,0.34814814814814815,-0.3823529411764717,-0.3823529411764717],[7,2,0.6592592592592592,1.344827586206897,1.344827586206897],[14,2,-5.326388888888894,1,-5.326388888888894,1]]],[6,[0,0.2076923076923077,0.4641025641025641,0.7974358974358975,1],[[14,2,12.277777777777777,1,12.277777777777777,1],[7,2,0.4666666666666666,-1.364197530864198,-1.364197530864198],[7,2,0.6518518518518519,1.5718954248366,1.5718954248366],[7,2,0.5,-2.355072463768116,-2.355072463768116],[14,2,-3.5767195767195745,1,-3.5767195767195745,1]]]],[53,1,1.5,[6,[0,0.2076923076923077,0.4641025641025641,0.7974358974358975,1],[[14,2,12.277777777777777,1,12.277777777777777,1],[7,2,0.4666666666666666,-1.364197530864198,-1.364197530864198],[7,2,0.6518518518518519,1.5718954248366,1.5718954248366],[7,2,0.5,-2.355072463768116,-2.355072463768116],[14,2,-3.5767195767195745,1,-3.5767195767195745,1]]]],[0]],[67,true,[15,1,[6,[0,0.9564102564102565],[[23,2,1],[27,2]]]],[0],[15,1,[6,[0,1],[[23,2,1],[27,2]]]],[9,1]],[40,[0],[0],[0]],[55,[0],[0],[0],[0]],[41,[0],[0],[0]],[42,[0],[0]],[43,[0],[0],[19],[19],-193],[69,11,12]],[59,"Effects",1,[15,9],[3,"7c6UMaeHRGY59TQoBiBger",1,0]],[12,"VFX",1,6,[21,35],[3,"50Zg1cB99BW5eU3j6FvhAA",1,0]],[64,0,2,false,false,12,[1,"260G2J5hVPK672b/Vckyby"],[[3,null],6,0],[52,[4,4288965879]],[9,5],[0],[0],[0],[0],[0],[0],[0],[9,0.5],[0],[0],[0],[[35,[9,1]],[65,0.1,[9,1]]],[105,true,[33,1,[36,[[20,255,0.45312499999999994],[20,0,0.7008928571428572]]]]],[107,2,0.1,1,1,0.5235987755982988,[0]],[37,true,true,[15,1,[6,[0,1],[[26,2,1,1,1],[38,2,1,1]]]],[15,1,[6,[0,1],[[66,2,0.07037037037037037,1.604938271604938,1,1.604938271604938,1],[26,2,1,1,1]]]],[15,1,[6,[0,1],[[66,2,0.07037037037037037,1.9259259259259258,1,1.9259259259259258,1],[26,2,1,1,1]]]],[0]],[68,[0],[53,1,2,[6,[0,1],[[7,2,-0.02962962962962963,2.316831683168317,2.316831683168317],[7,2,1,0.061465721040188284,0.061465721040188284]]]],[0],[9,1]],[40,[0],[0],[0]],[55,[0],[0],[0],[0]],[41,[0],[0],[0]],[42,[0],[0]],[43,[0],[0],[19],[19],-194],[111,2,4]],[64,0,2,false,false,9,[1,"ddFLNLeB1HYJT71ICggmeb"],[[5,null],6,0],[52,[4,4286930909]],[18,3,0.3,0.8],[0],[0],[18,3,14,16],[0],[0],[0],[0],[18,3,0.6,0.8],[9,4],[0],[0],[[35,[9,10]]],[54,[33,1,[36,[[20,255,0.5602678571428571],[20,0,0.7008928571428572]]]]],[108,true,0,0.2,1,0.5235987755982988,[0],[1,0,0,90]],[37,true,true,[15,1,[6,[0,1],[[26,2,1,1,1],[38,2,1,1]]]],[34,2,1.5,[6,[0,1],[[7,2,0.337037037037037,1.8383838383838382,1.8383838383838382],[39,2,-4.393518518518518,-4.393518518518518]]],[6,[0,0.4948717948717949,1],[[7,2,0.337037037037037,2.660818713450293,2.660818713450293],[23,2,0.26296296296296295],[39,2,-8.576388888888896,-8.576388888888896]]]],[34,2,1.5,[6,[0,1],[[7,2,0.3259259259259259,1.5888888888888895,1.5888888888888895],[39,2,-4.25079365079365,-4.25079365079365]]],[6,[0,0.47435897435897434,1],[[7,2,0.3333333333333333,2.3888888888888893,2.3888888888888893],[23,2,0.4222222222222222],[39,2,-3.611111111111112,-3.611111111111112]]]],[0]],[68,[0],[0],[0],[9,1]],[40,[0],[0],[0]],[110,true,0.5,[0],[0],[0],[9,2]],[41,[0],[0],[0]],[42,[0],[0]],[43,[0],[0],[19],[19],-195],[69,6,7]],[30,"VFX-Extra Particles",1,15,[[-196,[24,-197,[1,"ea0EARPwJPU6+XbT4Gtrgz"]]],1,4],[3,"a4wD91zBBP5Zeq7/J6jd1A",1,0]],[63,0,1,false,0,39,[1,"59VJQ3Y15Le4F3dj49/PPC"],[[8,null],6,0],[52,[4,4281281194]],[18,3,0.1,0.3],[0],[0],[18,3,4,8],[0],[0],[0],[9,0.05],[18,3,0.6,0.5],[9,1],[9,2],[0],[[35,[9,1]],[65,0.1,[9,1]]],[54,[33,1,[36,[[20,255,0.5602678571428571],[20,0,0.7008928571428572]]]]],[109,true,1,0.5,0.6,0.8,1,0.4537856055185257,[0],[1,90,0,0]],[37,true,true,[15,1,[6,[0,1],[[26,2,1,1,1],[38,2,1,1]]]],[34,2,2,[6,[0,0.32051282051282054,0.6461538461538462,1],[[14,2,8.233333333333334,1,8.233333333333334,1],[7,2,0.6925925925925925,-0.3823529411764717,-0.3823529411764717],[7,2,0.6074074074074074,1.344827586206897,1.344827586206897],[14,2,-5.326388888888894,1,-5.326388888888894,1]]],[6,[0,0.32564102564102565,0.658974358974359,1],[[14,2,8.233333333333334,1,8.233333333333334,1],[7,2,0.34814814814814815,-0.3823529411764717,-0.3823529411764717],[7,2,0.8111111111111111,1.344827586206897,1.344827586206897],[14,2,-5.326388888888894,1,-5.326388888888894,1]]]],[53,1,2,[6,[0,0.14102564102564102,0.4641025641025641,0.735897435897436,1],[[14,2,12.277777777777777,1,12.277777777777777,1],[7,2,0.4074074074074074,-3.3137254901960773,-3.3137254901960773],[7,2,0.6814814814814815,-0.19825708061002167,-0.19825708061002167],[7,2,0.45185185185185184,2.674897119341565,2.674897119341565],[14,2,-6.5,1,-6.5,1]]]],[0]],[67,true,[15,1,[6,[0,0.9564102564102565],[[23,2,1],[27,2]]]],[0],[15,1,[6,[0,1],[[23,2,1],[27,2]]]],[9,1]],[40,[0],[0],[0]],[55,[0],[0],[0],[0]],[41,[0],[0],[0]],[42,[0],[0]],[43,[0],[0],[19],[19],-198],[112,9]],[113,4,[1,"d3bUmRnohOXZH7U+/C23Va"],[15,1,[6,[0,0.5,1],[[27,2],[23,2,1],[27,2]]]],6],[16,"Blink",1,7,[41],[3,"32lqZTQTlGg6tuMKE2AWgs",1,0]],[97,2,1,[1,"50w1ILXFZEmrpNlu0WPrwd"],[1,1,0,1],[1,0,0,0]],[73,"Model Loader",1,24,[11],[[114,-200,[1,"b842qptw1IhYJLWHnyO/A6"],6,[[5,"bunny-0",25],[5,"bunny-1",26],[5,"bunny-2",27],[5,"bunny-3",28],[5,"bunny-4",29],[5,"bunny-5",30],[5,"bunny-6",31],[5,"bunny-7",32],[5,"drop-0",33],[5,"drop-1",34],[5,"drop-2",35],[5,"drop-3",36],[5,"drop-4",37],[5,"drop-5",38],[5,"drop-6",39],[5,"drop-7",40],[5,"frog-0",41],[5,"frog-1",42],[5,"frog-2",43],[5,"frog-3",44],[5,"frog-4",45],[5,"frog-5",46],[5,"frog-6",47],[5,"frog-7",48],[5,"whip-0",49],[5,"whip-1",50],[5,"whip-2",51],[5,"whip-3",52],[5,"whip-4",53],[5,"whip-5",54],[5,"whip-6",55],[5,"whip-7",56]],[[4,"37b85WpHzdBn41+pXJNQa6l","setTargetAnimation",14],[4,"1a3618UqwJAoY8Y8z5qOgFR","setModel",11],[4,"05d15J3lUpD5JAIXsL9fkKr","setModel",42],[4,"64be3B0iyJOGr/7vUdvlzSM","setModel",-199]]]],[3,"fcjqv53NhK+pyjjuLkn/4M",1,0]],[10,"Divide Start Color Min",1,16,[[13,"dark",-201,[1,"98J3lnE1BDp6Mf4aL+Sull"],[[4,"0c5d3ln13dJiYvGTuhGpTgh","setStartColorMin",2]]]],[3,"d0tUMBaxxI6otzOkpDJtK0",1,0]],[10,"Divide Start Color Max",1,16,[[13,"light",-202,[1,"ceflrm1ThDubBijR2j48tU"],[[4,"0c5d3ln13dJiYvGTuhGpTgh","setStartColorMax",2]]]],[3,"7bMoAk+GlKmLXzLUJSepDs",1,0]],[16,"Divide Extra Particles Color",1,16,[-203],[3,"07fLYLCNhPS6O3P3XYZ/px",1,0]],[16,"Divide Explode Color",1,16,[-204],[3,"1e1oGqTXRDIJueCFPl2WnP",1,0]],[10,"Unite Start Color Min",1,17,[[13,"dark",-205,[1,"ff7o7WSPRLQYNTOyEUKjdR"],[[4,"0c5d3ln13dJiYvGTuhGpTgh","setStartColorMin",2]]]],[3,"89sTpJ0t9KzLJx2UKS4EjX",1,0]],[10,"Unite Start Color Max",1,17,[[13,"light",-206,[1,"25C5Dvwp9D1pKkq5VQZMKc"],[[4,"0c5d3ln13dJiYvGTuhGpTgh","setStartColorMax",2]]]],[3,"8aov+DQVZDk4BaC5k3u0jG",1,0]],[16,"Unite Extra Particles Color",1,17,[-207],[3,"e75K7VXKNKm4cCXYC3jcGF",1,0]],[16,"Unite Expand Color",1,17,[-208],[3,"f1/GfexIRHUpiLBxkGYgn1",1,0]],[16,"Speed Boost Start Color Min",1,25,[-209],[3,"5ereLhLWBKV42DviTgDC4P",1,0]],[16,"Speed Boost Start Color Max",1,25,[-210],[3,"9cUB56BAtJR45fX+RD1ruZ",1,0]],[16,"Floor Trail Color",1,25,[-211],[3,"48tAEnnSJO9KJG4qNp3awl",1,0]],[12,"VFX-Vanish",1,11,[-212,-213],[3,"92roK6sSRCNp1Q5pAeGgD4",1,0]],[10,"Vanish Start Color",1,56,[[13,"default",-214,[1,"0d/C3oZBJDDbB3JR1jUOQs"],[[4,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor",9]]]],[3,"7b/RjEA3xBSYZXhoo47NxP",1,0]],[10,"Burst Start Color",1,56,[[13,"default",-215,[1,"d5DVEQjfZPnrjbOVpqjJ9u"],[[4,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor",12]]]],[3,"devs2P9PJMILKJy3WJlPl+",1,0]],[10,"Player Indicator",1,11,[[13,"default",-216,[1,"98J3lnE1BDp6Mf4aL+Sull"],[[4,"3bad91bJJROtrq/iYNkKQPI","setColor",26]]]],[3,"f3/PEHpe5DCq8G9A3aJESH",1,0]],[60,"Shadow_01.002",false,5,[[70,-217,[1,"55GcNbAN9HDpjQfDVMTqpI"],[14],[56],15]],[44,"beBR4u63hG0r3AcRga+N66",1,16],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,80.27849578857422,80.27849578857422,100],[1,-90.00000965934633,0,0]],[60,"Shadow_01.003",false,5,[[70,-218,[1,"4472yCbzRDb5grJoM132Tx"],[17],[56],18]],[44,"7df/0VvUpJ/7g7ySaz4ALT",1,19],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,80.27849578857422,80.27849578857422,100],[1,-90.00000965934633,0,0]],[10,"Disabler",1,7,[[116,-219,[1,"dfOxtIVmBMH4Zcdpdk6ARu"],8,[38,37],[[4,"cc.ParticleSystem","play",9],[4,"cc.ParticleSystem","play",12],[4,"c83f3h67FpJDoLcaBUEDjiF","deactivate",5],[4,"c83f3h67FpJDoLcaBUEDjiF","deactivate",15],[4,"998c54116RP+60xSJ3vqUX7","deactivateMovement",10]]]],[3,"0b+YujF25C17t39A1xrYXk",1,0]],[10,"Scale",1,27,[[117,0.05,0.95,-220,[1,"4d9Nt8KMNEnJfEuuh9qRLN"],[[4,"12ea43w32ZDAL2+IVCNZlsZ","setEndValue",1],[4,"12ea43w32ZDAL2+IVCNZlsZ","play",1]],1,58]],[3,"83QzYUMB1IEpQX/Rirwhlg",1,0]],[10,"Animation Blend",1,27,[[118,-222,[1,"51/uFxGspFfrphj2HcmDSp"],-221]],[3,"eaw8gh2alCd6wY7+eaMR5X",1,0]],[10,"DivideSfx",1,29,[[51,-223,[1,"d4agoj/RxGD6oAXl2HF32S"],61]],[3,"1bu1UmatVA/5u0IsGEPGy/",1,0]],[10,"UniteSfx",1,29,[[51,-224,[1,"54SD1c2mtA7YxlRTANVMC/"],62]],[3,"77uHiGaktFmrj/T/B5B3bL",1,0]],[119,29,[1,"6e1B9x2kRAzZMuX8DJgdv8"],8,[[4,"cc.ParticleSystem","play",2],[11,"cc.ParticleSystem","play"],[11,"cc.ParticleSystem","play"],[4,"ac879rTendCEbpZWFz/jexs","playSFX",65]],[[4,"ac879rTendCEbpZWFz/jexs","playSFX",66]],4],[10,"Absorb Players outter Trigger",2,6,[[62,true,0.8,3,-225,[1,"d2lB1F5rJGK5IhM3A9QsRZ"],[1,0,1,0]],[50,4,4,-226,[1,"6dzpdbRvFAVo3luhIVIW9F"]]],[3,"d4+8xXB4pNDJdtQPx+AnDA",1,0]],[62,true,0.05,3,20,[1,"3ccgyRzpxF+4lHkGbnz7RE"],[1,0,1,0]],[12,"Animation",1,7,[14],[3,"2eSxxtz5lKGoGmgLpbKYZF",1,0]],[120,14,[1,"86yQcOWvRIlbLBJCisbKhG"]],[16,"Input",1,7,[-227],[3,"8bQ8wB0utAh6d4ROPIIzua",1,0]],[121,72,[1,"3ddr6uWNtNyJqVnIhtjL7R"]],[12,"Physics",1,7,[10],[3,"28/sj+dNFEoK+99/2ZFGtX",1,0]],[122,1000,10,10,[1,"a21G99zLhK8r/6dbEqul01"],43,33,8],[13,"default",47,[1,"2dOn7kUsdKA4yeXtcZCV7l"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor"]]],[13,"dark",48,[1,"12vC3jsGNEwKfk/tju3qIz"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor"]]],[13,"dark",51,[1,"5axeIJIvdKooxoLPclSeau"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor"]]],[13,"dark",52,[1,"d3QPRgnF5DHbHtNVXY6kZc"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor"]]],[13,"dark",53,[1,"a2GBtDWDpNrJdIVbhNVlmf"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColorMin"]]],[13,"light",54,[1,"d8/iurEK5CSb3AZEYd8eEY"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColorMax"]]],[13,"dark",55,[1,"89aOOFqxVHYoqGPyc6ndWK"],[[11,"0c5d3ln13dJiYvGTuhGpTgh","setStartColor"]]],[115,"Quad<ModelComponent>",26,[1,"04DXdN2HdOUbqQ3OSn/guW"],[23],[56]],[10,"Face Forward",1,24,[[123,-228,[1,"b9ZCjlkUZOiYoEfzPC/Xpi"],6,75]],[3,"d2aEVsH3RIFZxSNVPkBWQ+",1,0]],[74,"Shoot",false,1,28,[[124,false,-229,[1,"4dZSTYbqRLg58ExIEicKkX"],8,43,6,[[11,"cc.ParticleSystem","play"],[49,"37b85WpHzdBn41+pXJNQa6l","setTrigger","shoot",14]],59,60]],[3,"35wZ9DkKpHU5K8aDIO7AQj",1,0]],[75,"Divide Target Point",1,6,[3,"4bMbqT4P5PuKVhIWa+giWp",1,0],[1,0,0,-2.5]],[12,"Game",1,7,[-230],[3,"0bgs+LJpBP5LZS9K5eiuzD",1,0]],[10,"Game Started",1,87,[[125,"menu-start-clicked",-231,[1,"ccpNaZ1vFJH7al4QlepRMH"],[[4,"998c54116RP+60xSJ3vqUX7","activeMovement",10]]]],[3,"06PSRxOn9BRoA43D1IAPYM",1,0]],[16,"World Shadow",1,7,[31],[3,"7aF+SBy6NPEIuwjA4wTfOI",1,0]],[103,true,0.7,32,[1,"857ZwAUOxHcrDZfeM+xkL/"],[1,0,0.6,0]],[12,"Listeners",1,1,[-232],[3,"7c4745AXVOy7DNN0UhNigX",1,0]],[10,"Victory",1,91,[[126,3,-233,[1,"25n1TfGOZJ3KbaJnZHtu8D"],[[4,"998c54116RP+60xSJ3vqUX7","deactivateMovement",10]]]],[3,"8cEz4r/UhAIZa1lzQqG7Rp",1,0]]],0,[0,-1,2,0,-2,4,0,-3,3,0,-4,5,0,0,3,0,0,3,0,0,3,0,0,3,0,0,2,0,3,2,0,0,2,0,0,2,0,0,2,0,0,3,0,3,13,0,0,3,0,3,13,0,0,3,0,3,13,0,0,3,0,3,13,0,0,3,0,3,3,0,0,3,0,3,13,0,0,3,0,3,13,0,0,2,0,3,76,0,0,2,0,3,77,0,0,3,0,3,82,0,3,41,0,0,3,0,3,80,0,0,3,0,3,81,0,0,2,0,3,67,0,0,2,0,3,67,0,0,4,0,3,78,0,0,4,0,3,79,0,0,4,0,3,4,0,0,4,0,3,4,0,0,4,0,3,4,0,0,4,0,3,4,0,0,5,0,3,31,0,0,5,0,3,31,0,0,5,0,3,31,0,0,5,0,3,5,0,7,1,0,-1,8,0,-2,43,0,-3,33,0,0,1,0,1,1,0,1,1,0,-1,6,0,-2,7,0,-3,91,0,1,2,0,7,2,0,4,23,0,4,23,0,4,23,0,4,23,0,7,3,0,4,22,0,4,22,0,4,22,0,4,22,0,7,4,0,4,18,0,4,18,0,4,18,0,4,18,0,4,18,0,1,5,0,-1,26,0,-2,60,0,-3,61,0,7,5,0,-1,20,0,-2,68,0,-3,32,0,-4,36,0,-6,86,0,-1,70,0,-2,72,0,-3,74,0,-4,24,0,-5,28,0,-6,87,0,-7,42,0,-8,62,0,-9,89,0,0,9,0,0,12,0,0,19,0,0,63,0,0,64,0,-1,34,0,-2,40,0,-1,38,0,1,9,0,1,9,0,-1,12,0,-1,75,0,17,73,0,0,10,0,1,10,0,0,45,0,0,46,0,0,47,0,0,48,0,0,53,0,0,54,0,0,55,0,0,49,0,0,50,0,0,51,0,0,52,0,0,57,0,0,58,0,0,59,0,1,11,0,-1,16,0,-2,17,0,-3,25,0,-4,56,0,-5,59,0,-1,37,0,1,12,0,1,12,0,0,19,0,0,14,0,0,19,0,0,30,0,0,14,0,-1,71,0,-1,34,0,1,15,0,-1,39,0,-1,45,0,-2,46,0,-3,47,0,-4,48,0,-1,49,0,-2,50,0,-3,51,0,-4,52,0,1,19,0,-1,69,0,1,20,0,15,69,0,1,20,0,-1,44,0,-2,84,0,-3,27,0,-1,53,0,-2,54,0,-3,55,0,-1,83,0,18,83,0,1,26,0,-2,63,0,-3,64,0,-1,85,0,-2,29,0,-3,30,0,-1,67,0,-1,65,0,-2,66,0,1,30,0,-2,60,0,-3,61,0,1,32,0,-2,90,0,15,90,0,1,32,0,9,34,0,9,37,0,9,38,0,-1,40,0,1,39,0,9,40,0,0,62,0,1,44,0,1,45,0,1,46,0,-1,76,0,-1,77,0,1,49,0,1,50,0,-1,78,0,-1,79,0,-1,80,0,-1,81,0,-1,82,0,-1,57,0,-2,58,0,1,57,0,1,58,0,1,59,0,1,60,0,1,61,0,1,62,0,1,63,0,19,71,0,1,64,0,1,65,0,1,66,0,1,68,0,1,68,0,-1,73,0,1,84,0,1,85,0,-1,88,0,1,88,0,-1,92,0,1,92,0,14,1,2,5,21,3,5,21,4,5,21,5,5,6,8,20,41,8,21,33,9,5,35,10,5,74,11,5,44,13,1,30,14,5,70,15,5,35,19,5,27,21,5,36,31,1,89,35,5,36,41,1,42,67,22,86,233],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,67,13,41,8,8,8],[6,6,6,-1,10,-1,8,10,-1,10,-1,8,10,6,-1,8,6,-1,8,6,11,11,11,-1,6,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,12,12,16,23,13,13,13,24,8,25,16,26,12,27,28],[7,8,9,10,11,0,5,1,0,1,0,5,1,12,13,6,2,14,6,2,3,3,3,15,2,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,4,4,48,49,50,51,52,53,54,55,56,57,4,58,59]],[[[127,"builtin-unlit",[{"hash":3319190198,"name":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":2,"defines":["USE_TEXTURE"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  layout(location = 13) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture2D(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":197,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":41}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}]}],[{"name":"opaque","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"transparent","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"add","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]}]]],0,0,[],[],[]],[[[128,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"mainColor",8,[4,4289168880],"mainTexture",6,0]],11]]],0,0,[0,0],[29,30],[60,61]]]]
